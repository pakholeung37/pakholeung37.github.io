{"componentChunkName":"component---src-templates-blog-post-js","path":"/vite-plugin-vue2-svg插件开发和总结/","result":{"data":{"site":{"siteMetadata":{"title":"银凤梨"}},"markdownRemark":{"id":"b8e34950-b7f9-5edf-b2ef-b724aae60be3","excerpt":"前言 最近在做旧项目（vue2）的 vite 工程化改造中，遇到了 svg 引入和优化的问题。因为 vite 是相对新的一个工程工具，所以相应的生态也不是特别丰富。目前这个阶段而言，关于可用的 vite svg 工程化库有三个，分别是vite-svg, vite-svg-loader, vite-plgin-svg…","html":"<h2>前言</h2>\n<p>最近在做旧项目（vue2）的 vite 工程化改造中，遇到了 svg 引入和优化的问题。因为 vite 是相对新的一个工程工具，所以相应的生态也不是特别丰富。目前这个阶段而言，关于可用的 vite svg 工程化库有三个，分别是<a href=\"https://github.com/visualfanatic/vite-svg/tree/master/packages/vite-plugin-vue-svg\">vite-svg</a>, <a href=\"https://github.com/jpkleemans/vite-svg-loader\">vite-svg-loader</a>, <a href=\"https://github.com/meowtec/vite-plugin-svg-sprite\">vite-plgin-svg-sprite</a>。这里面前两个库都是针对 vue3 的，所以排除了，只剩下 vite-plugin-svg-sprite 可选。这个库的功能还是比较齐全的，单 svg svgo 优化，svg sprite，框架无关，算是很不错的选择。介意的地方有几个</p>\n<h3>模版代码</h3>\n<p>在调用上，不是特别清晰，需要写一些模版代码，下面是一个比较典型的 svg 引用</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;svg&gt;&lt;use :xlink:href=&quot;`#${icon}`&quot;&gt;&lt;/use&gt;&lt;/svg&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport icon from &quot;./icon.svg&quot;\nexport default {\n  data() {\n    return {\n      icon,\n    }\n  },\n}\n&lt;/script&gt;</code></pre></div>\n<p>可以看到，处理引入 svg，还需要写一些模版 template 才可以引用真正的 svg</p>\n<h3>动态加载</h3>\n<p>这个是 svg sprite 的通病，因为 svg sprite 需要把所有 svg 全部压在一个文件里面，这样你的网站加载的时候只能一次性把所有需要用到的 svg 加载进来，没办法加载到页面的决定性的资源。我猜测这是大部分网站放弃 svg sprite 的原因。目前比较主流的方法都是将 svg 转换成组件使用的。</p>\n<h2>vite-plugin-vue2-svg 插件开发</h2>\n<p>看了这几个插件的源码，发现现阶段没有特别适合 vue2 的方案，所以决定开发一个新的插件<a href=\"https://github.com/pakholeung37/vite-plugin-vue2-svg\">vite-plugin-vue2-svg</a>。虽然以前也有一些插件开发和包发布的经验，但是这次决定采取更高的标准去完成这件事。</p>\n<h2>工具栈</h2>\n<p>这次选用的组合是 yarn、typescript，以及一些必要的规范工具。</p>\n<h2>开发</h2>\n<p>这个插件是参考 vite-svg 完成的。在 compileSvg 的阶段有一些麻烦。这个函数主要的作用是接受一个 svg file 的 content，然后返回 vue component 的 file content\n一开始选择纯手撸 render</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">compileSvg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">svg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    export default {\n      render(h) {\n        h('span', {\n          domProps: {\n            innerHTML: '</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>svg<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">',\n          }\n        })\n      }\n    }\n  </span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>咋一看好像没有什么问题，但是问题很大</p>\n<ol>\n<li>svg 需要由一个 wrapper tag 包裹，这样在调用时一些 dom props 就没办法传递到真正的 svg tag 上面。</li>\n<li>有 xss 风险，这里将一个 svg 作为 innerHTML 直接插入到 dom 中，如果 svg 文件里面有一些 script 标签，也会一并插入到 dom 中，虽然所有的 svg 都来自内部，但是作为一个插件开发者应该考虑各种状况。</li>\n</ol>\n<p>所以看来，得上 vue template compiler 了</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> compile <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"vue-template-compiler\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">compileSvg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">svg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">compile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span>\n    source<span class=\"token operator\">:</span> svg<span class=\"token punctuation\">,</span>\n    filename<span class=\"token operator\">:</span><span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>code<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里又有一个比较麻烦的地方，我使用 vue-template-compiler 编译后，代码中有<code class=\"language-text\">with(this)</code>的代码，这样根本没办法在严格模式下运行。果不其然，引用后直接就报错了。</p>\n<p>于是我参考了另一个库 vite-plugin-vue2，它里面使用了一个@vue/component-compiler-utils 的包，用于将*.vue 文件编译出 vue component。于是最终代码变成这样</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> compileTemplate<span class=\"token punctuation\">,</span> parse <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@vue/component-compiler-utils\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> compiler <span class=\"token keyword\">from</span> <span class=\"token string\">\"vue-template-compiler\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">compileSvg</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">svg</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> template <span class=\"token operator\">=</span> <span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    source<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      &lt;template>\n        </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>svg<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\n      &lt;/template>\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    compiler<span class=\"token operator\">:</span> compiler<span class=\"token punctuation\">,</span>\n    filename<span class=\"token operator\">:</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>template<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>template<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">compileTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    compiler<span class=\"token operator\">:</span> compiler<span class=\"token punctuation\">,</span>\n    source<span class=\"token operator\">:</span> template<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">,</span>\n    filename<span class=\"token operator\">:</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>result<span class=\"token punctuation\">.</span>code<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\n    export default {\n      render: render,\n    }\n  </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>整体看上去还是比较简洁的。</p>\n<h2>打包</h2>\n<p>一开始是使用 rollup 打包，但是总是发现会将一些外部的包引入到最终代码中，导致运行报错，一开始没意识到这个插件在 node 中运行，其实只需要将 typescript 编译到 javascript 就可以了，后来放弃使用 rollup 包，只使用 tsc 即可。</p>\n<h3>tsc 配置</h3>\n<p>tsconfig 打包配置有几个关键的字段是要声明的</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"target\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"es5\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里其实填es6也是可以的，毕竟只是在node中运行</span>\n    <span class=\"token property\">\"module\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"commonjs\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 会添加额外的runtime将import转换成cjs。虽然有些node开了esmodule实验特性，不过还是转换比较好</span>\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./lib\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里是输出目录</span>\n    <span class=\"token property\">\"declaration\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// 这一步会确定*.d.ts文件会不会输出到目录，没有这个type文件，那你的插件就没办法被正确的类型推断</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>调试</h2>\n<p>以往的调试我都是直接在 src 里面加调试文件和代码做调试的，所以这次参考了其他一些库，更加标准地做这件事。</p>\n<p>这里主要是将一个调试用的项目放在/examples 目录下，与 src 文件夹区分开来。examples 下是一个完整的 vite 项目，可以用于测试插件。主要的难点是如何将插件链接到这个项目中。\n一开始使用 yarn 本地依赖的方法，在 package.json 中添加<code class=\"language-text\">&quot;vite-plugin-vue2-svg&quot;: &quot;file:../&quot;</code>，这样 yarn 会将插件的目录链接到调试项目中。但是这里有一个问题，每次修改完代码我都需要重新 build 然后<code class=\"language-text\">yarn --force</code>安装依赖，过程比较缓慢。</p>\n<p>后来我参考了<code class=\"language-text\">yarn link</code>的方案，彻底解放调试效率。</p>\n<h2>发版</h2>\n<p>npm 发包需要在 package.json 填写一些必要的字段</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  ...\n  <span class=\"token property\">\"main\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"lib/index.js\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里需要指定包入口文件</span>\n  <span class=\"token property\">\"types\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"lib/index.d.ts\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 这里需要指定types入口</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"lib\"</span>\n  <span class=\"token punctuation\">]</span> <span class=\"token comment\">// 这个字段比较关键， 我一开始发包的时候，尝试数次都只能将*.js发上去，自动忽略了*.d.ts和sourcemap，指定了这个字段后，该目录下所有文件都会入npm包</span>\n  ...\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然后执行<code class=\"language-text\">yarn publish --registry=&quot;https://registry.npmjs.org/&quot;</code>，添加后面 registry 是因为我用的是 taobao 源，所以发版会发不上去，需要将注册源临时换到官方 npm</p>","frontmatter":{"title":"vite-plugin-vue2-svg插件开发和总结","date":"March 03, 2021","description":""}}},"pageContext":{"slug":"/vite-plugin-vue2-svg插件开发和总结/","previous":{"fields":{"slug":"/svg优化及相关思考/"},"frontmatter":{"title":"svg优化及相关思考"}},"next":null}}}