{"componentChunkName":"component---src-templates-blog-post-js","path":"/CRP资源整理及quick quiz/","result":{"data":{"site":{"siteMetadata":{"title":"银凤梨"}},"markdownRemark":{"id":"2c77ed3f-64bf-51e3-ab75-2486c8ce84c6","excerpt":"Google DeveloperCRP 系列文章 和上面文章同一作者的 Udacity 课程：网站性能优化 CRP 详述：understanding critical render path | bitofcodes async 和 defer javascipt 在 CRP 理论下的分析：Asynchronous…","html":"<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/\">Google DeveloperCRP 系列文章</a></li>\n<li>和上面文章同一作者的 Udacity 课程：<a href=\"https://classroom.udacity.com/courses/ud884\">网站性能优化</a></li>\n<li>CRP 详述：<a href=\"https://bitsofco.de/understanding-the-critical-rendering-path/\">understanding critical render path | bitofcodes</a></li>\n<li>async 和 defer javascipt 在 CRP 理论下的分析：<a href=\"https://bitsofco.de/async-vs-defer/\">Asynchronous vs Deferred JavaScript</a></li>\n<li><code class=\"language-text\">&lt;script&gt;</code>标签位置方案详述：<a href=\"https://www.html5rocks.com/en/tutorials/speed/script-loading/\">Deep dive into the murky waters of script loading</a></li>\n</ul>\n<h2>quick quiz</h2>\n<p>Q：请简述 critical render path。</p>\n<p>A：在浏览器请求资源的时候，最先请求到的一定是一个 html 文件，所有的其他资源一定是围绕这个入口进行加载的。关键渲染路径就在于浏览器加载其他资源和构建相关模型以及渲染到屏幕的策略。</p>\n<p>一个正常的 CRP 包含以下步骤：</p>\n<ol>\n<li>构建 DOM</li>\n<li>构建 CSSOM</li>\n<li>运行 JavaScript 脚本</li>\n<li>创建渲染树</li>\n<li>生成布局</li>\n<li>绘制画面</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4613ac68a76ed8e8429de3f5a766adff/0f2bc/1240-20200817211711642.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.054054054054056%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABKklEQVQY02NgAILHgj2ML9i7OV4xVHE+5+hmB4m9ZO5ieMPQzUAWeM/QIfOOuffVL+HZ/98xdO0Hib1h7mHdGtzD8Ia7n/m97AyWN2y9zOuS+hhA9Hup6Sxv2HuZF1RMYHjN2sP8Tnwqy1vmHuY3DC0IQx9K9GW/E5hUfkeqJ5SBEvCOta/7teSUeffFe5IY/jMwPJLsb38nPGXOG5aevBWpPfxvOPua34lMmQ3kl2+J6BMB0jXvhCbPfsPaW7W4uJ/vNUtPBdAhs98y9TS9YWjjYHjL1X/7g8rsj28YuhYcsu5Sfc814fwHrXmf33D0rV4Z2SEGpM++V5z1CWjAzm1BvTJAAw++E5z8GUjvX1LUL/KGuXvPO76Jn4AGngYayIPh4lIGZYp8DAAmV3+u+gqXpwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"image\"\n        src=\"/static/4613ac68a76ed8e8429de3f5a766adff/fcda8/1240-20200817211711642.png\"\n        srcset=\"/static/4613ac68a76ed8e8429de3f5a766adff/12f09/1240-20200817211711642.png 148w,\n/static/4613ac68a76ed8e8429de3f5a766adff/e4a3f/1240-20200817211711642.png 295w,\n/static/4613ac68a76ed8e8429de3f5a766adff/fcda8/1240-20200817211711642.png 590w,\n/static/4613ac68a76ed8e8429de3f5a766adff/0f2bc/1240-20200817211711642.png 742w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>一般而言，这个过程是顺序执行的，唯一需要关注的，是 JavaScript 如何影响 DOM 和 CSSOM 的构建。</p>\n<p>JavaScript 是一种解析阻塞的资源。一旦 html 解析器遇到一个 script 标签，它将会立即加载并执行脚本，同时 blocking html parser。而且，script 还可能会改变一些样式，这意味着，脚本将会在 CSSOM 构建完毕后才会执行。这里有一篇参考文章：<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript\">使用 JavaScript 新增互動功能</a>。</p>\n<p>关键路径决定了页面将会如何呈现到客户端，并决定了呈现的速度。关键路径的优化则会影响页面首次加载的性能。</p>\n<p>一般而言，首次加载的性能瓶颈一般是在网络上和解析上。加载资源的顺序和速度会直接影响首次加载的性能。所以对于如何优化关键路径，可以分为两大类：1、尽早加载网页关键资源，例如关键\nCSS 和关键 JS。2、优化可能产生阻塞的代码，例如 js 运行阻塞 dom 构建等。</p>\n<p>Q：简述 async 脚本的执行路径。</p>\n<p>A：async 是 HTML5 的提案，目的是防止阻塞 dom 构建，async 脚本将会并行 dom 构建进行加载，并且在加载完毕后立刻执行。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a9a9694452a0495fd7fa751b9f8bb028/6937a/1240-20200817211711742.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsSAAALEgHS3X78AAABEUlEQVQY0yWQ23aDIBBF/f9/60Nf+tBEk6YRTVC8AALedkfLWrNgAefMnpMZY3Decaxt2849xAmlFOu6smyJuFjm1ePiiBk3uhFSH1isOd9iHJiTPbXZs3xwu+eYrmFnFdMZ63qK25WYAmEeseEtZg2919QCULWGbmgI4YWNGjcoZtex7SuZ1m9K9aRp3tIpSI8d70cu12/SfNCNjCJ0Iuyc5l5riqrm+VA0r4ohHYYlybai3MlUVfL4/aEoruT5ha43DIMRwpyUIml1eBFNi9yHFtUKZaf5vBk+vmqcfuCtYlkmIdzIUhKKGM+a5//zQea9PzMdXEOtNb0uMb0mLUGoJ4likki8DCR/bIP1w5nhHyLtfssUCwkDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"image\"\n        src=\"/static/a9a9694452a0495fd7fa751b9f8bb028/fcda8/1240-20200817211711742.png\"\n        srcset=\"/static/a9a9694452a0495fd7fa751b9f8bb028/12f09/1240-20200817211711742.png 148w,\n/static/a9a9694452a0495fd7fa751b9f8bb028/e4a3f/1240-20200817211711742.png 295w,\n/static/a9a9694452a0495fd7fa751b9f8bb028/fcda8/1240-20200817211711742.png 590w,\n/static/a9a9694452a0495fd7fa751b9f8bb028/efc66/1240-20200817211711742.png 885w,\n/static/a9a9694452a0495fd7fa751b9f8bb028/6937a/1240-20200817211711742.png 1094w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Q：简述 defer 脚本的执行路径。</p>\n<p>A：如上图，defer 一样可以并行 dom 构建加载，并会在 dom 构建完毕后立刻执行。</p>\n<p>Q：为什么要使用 async 和 defer，它们又有什么问题。</p>\n<p>A：async 和 defer 的都是为了防止原始脚本标签阻塞 dom 构建而提出的，并行加载可以让他们更快地加载。但是同样，他们两者也有问题。第一、async 和 defer 都无法保证脚本的执行一致性。</p>\n<p>例如一下代码</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">// async提案\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">async</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">async</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n// defer提案\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">defer</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">defer</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>async 在这种代码中，无法保证 1.js 运行在 2.js 之前，defer 则会在某些浏览器中存在 bug 导致 2.js 部分代码可能提前与 1.js。致使两个脚本无法顺序运行。defer 提案由于严重的 bug，现在几乎不会用了。async 则只会使用在独立的，关键的脚本之上。</p>\n<p>Q：请比较 async 和 defer 异同。</p>\n<p>A：上面说的也很详细，async 和 defer 都能并行于 parser 加载，不同是 async 会在加载完成时执行，defer 则在 dom 构建完成时执行。</p>\n<p>Q：如何应用 CRP 分析加快网站的加载速度。</p>\n<p>A：上面也说到过，关键在于如何尽早地加载关键资源和防止阻塞 dom 构建。</p>\n<p>能用的策略包括：</p>\n<ol>\n<li>最小化、压缩、缓存关键资源。</li>\n<li>\n<p>最小化渲染阻塞资源。</p>\n<ul>\n<li>使用 media query 防止加载非关键 CSS</li>\n<li>使用 inline CSS</li>\n</ul>\n</li>\n<li>\n<p>最小化解析阻塞资源。</p>\n<ul>\n<li>推迟 JavaScript 执行</li>\n<li>异步加载 JavaScript</li>\n</ul>\n</li>\n</ol>\n<p>Q：综述 script 标签放置问题。</p>\n<p>A：<a href=\"https://www.html5rocks.com/en/tutorials/speed/script-loading/#toc-enough\">https://www.html5rocks.com/en/tutorials/speed/script-loading/#toc-enough</a>自己看吧。</p>","frontmatter":{"title":"CRP资源整理及quick quiz","date":"December 12, 2019","description":""}}},"pageContext":{"slug":"/CRP资源整理及quick quiz/","previous":{"fields":{"slug":"/TypeScript：最佳实践/"},"frontmatter":{"title":"TypeScript：最佳实践"}},"next":{"fields":{"slug":"/Advanced Vue Featrues - Reactivity/"},"frontmatter":{"title":"Advanced Vue Featrues - Reactivity"}}}}}