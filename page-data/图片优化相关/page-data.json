{"componentChunkName":"component---src-templates-blog-post-js","path":"/图片优化相关/","result":{"data":{"site":{"siteMetadata":{"title":"银凤梨"}},"markdownRemark":{"id":"aacb7c30-fdad-534c-ab85-207e60f650e9","excerpt":"前言 在部分场景下, 设计器可能会在滚动过程中造成严重影响体验的卡顿【pc—页面滚动到一个放了十几张超过 1m 的图片的多图文模块时就会卡顿】在本次案例中, 将针对多图文模块进行优化, 希望通过这次优化, 提供普适的解决方案. 图片懒加载 图片懒加载应该是非常常用的技术, 目前的技术方案大概有原生 onscrll…","html":"<h2>前言</h2>\n<p>在部分场景下, 设计器可能会在滚动过程中造成严重影响体验的卡顿<a href=\"https://www.tapd.cn/30747598/bugtrace/bugs/view?bug_id=1130747598001029787\">【pc—页面滚动到一个放了十几张超过 1m 的图片的多图文模块时就会卡顿】</a>在本次案例中, 将针对多图文模块进行优化, 希望通过这次优化, 提供普适的解决方案.</p>\n<h2>图片懒加载</h2>\n<p>图片懒加载应该是非常常用的技术, 目前的技术方案大概有原生 onscrll + 类 getBoundingClientRect api(如 offsetTop, clentHeight)之类的, 第二种是使用 IntersectionObserver API.</p>\n<h3>原生 onscroll + 类 getBoundingClientRect api</h3>\n<p>优点是各浏览器支持良好, 缺点也很明显, 这类计算位置的 api 会导致回流, 强制重绘, 可能造成页面闪烁, 并且可能引起额外的卡顿, 必须通过节流等手段降低调用频率.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/bf6721af259146e2d2315dfb7a764d17/fdaf8/20200531105917-4ea51960-edc8-4c07-8828-8f6e78a9f733.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABdUlEQVQoz01R2Y7cIBD0///VKop2smuDMTZjwJjbt2cmG+U95TxEkUqourqqG0SxPn4C++uXz8vg4nK+ABMyADIfz7wdcdlBYIOoXQKZ9ge6xb+wy4uywU8rCACfzQtK4G8mSOO0jdoGmxaXlsHn4r/Nq/EJI9N6YI++Bm0o5/OprEcLyuASbgdu06xdLLbnF5Ln1+84b1woG2fj8xgmmGA1QJjUiFjEiRZEaby2mBULPNWlOUyrGt2NlI2803tbi5ZJUfcdOBUXUFZtA4XrnggOwmRXdFKr0Q82dFp3M9fnXe5Cnb1+9P0u5CHMUymIh7j04+pe/BAwFKzr8Yb5eOkQfugbn1g7MZzi6Jpcs0BYpEAdqtY1IXkeGfUl9RVPdXHXZowTPkNa+6Heeax5pE0gSlWtKetI2lw3oUKgtSwE3zjSJMoxN9JC+mzSavLWjva7vFWeVp6UYyXevhF+K1PdzG3pyIctqWGD8+VISWR1aj4d+QPTxNTpjIdfXQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/bf6721af259146e2d2315dfb7a764d17/fcda8/20200531105917-4ea51960-edc8-4c07-8828-8f6e78a9f733.png\"\n        srcset=\"/static/bf6721af259146e2d2315dfb7a764d17/12f09/20200531105917-4ea51960-edc8-4c07-8828-8f6e78a9f733.png 148w,\n/static/bf6721af259146e2d2315dfb7a764d17/e4a3f/20200531105917-4ea51960-edc8-4c07-8828-8f6e78a9f733.png 295w,\n/static/bf6721af259146e2d2315dfb7a764d17/fcda8/20200531105917-4ea51960-edc8-4c07-8828-8f6e78a9f733.png 590w,\n/static/bf6721af259146e2d2315dfb7a764d17/fdaf8/20200531105917-4ea51960-edc8-4c07-8828-8f6e78a9f733.png 674w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>IntersectionObserver</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\">Intersection Observer</a> API 提供了一种异步观察目标元素与祖先元素或顶级文档<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport\">viewport</a>的交集中的变化的方法。利用这个 api 可以实现懒加载. 优点是使用浏览器的 api, 只有回调的部分是在主线程运行, 更快更高效. 缺点是在 IE 和低版本 Safari 支持不佳. 当然为了支持低版本, w3c 提供了<a href=\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill\">polyfill</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1725ffe00c17149cd8a4f3b06e8a2e06/9bb7a/20200531105917-74697407-d67d-4b90-8a62-d361366e2f62.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.54054054054055%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACEklEQVQoz01RWbKcMAzk/gdL5TEDNjZesfFuY5h5S5IDRPM+UlF1UY2Q1C009PcvwPX5O5TD+HQ8PwE2FgCQ9vgo5zMdFxAog+TmE5B6vcPX4V+zL4faQ6gdiC/NhuzK8Xqt3YaiXZTWwVO74HIDmJCH/5VhMIzM/XE8PzYXYztBELh2HmZtPoIsuIMylyuQ4fz4BXh8/QGRVW6hdJeaz83GvMeyxwpGNpe+m19tO5A9mlCMywOsBACFPdUf94kIiRjHjBMmFi4wF/O6ziuD/ETpwhXT20xXyBMhBumTDmWLFQlJIpKX4MfKMqkLto6yk8nO1SnEyVVVIUbVhehMHEyefNBgI1aTGlaKZKyeQl5cVNIprrvZz11cVF1cPth2qFZbOqLukl9UP/mwGjfJjbs8rQyFSZwrLQtNqOIpbtIWa5oGKd5XVUSGSNllux0SMgPRlsHu/QF73uzbkubJjZN5i7eR6xuOWAdBMyYFsUD9d2ineWBLRoPYI9yzXe+I89mNoq9rI8jd8jxpg5aGSEWsUX4QmTnIAkTiS515owPVFgntS4dfejM/wTOYn+wYbqNQdxRmYjHNCykYlIMPENwwbGcCyosyE1N7aoi9mklC0z7ezZsfRy7B9qKCJAlD6eqJd9+2dyVetueB20CNgzu/LuzvrBGcZuzvBd03g0jDkIHj8U5V4SXnkovMglbED/oXA9aiytJ/HDwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/1725ffe00c17149cd8a4f3b06e8a2e06/fcda8/20200531105917-74697407-d67d-4b90-8a62-d361366e2f62.png\"\n        srcset=\"/static/1725ffe00c17149cd8a4f3b06e8a2e06/12f09/20200531105917-74697407-d67d-4b90-8a62-d361366e2f62.png 148w,\n/static/1725ffe00c17149cd8a4f3b06e8a2e06/e4a3f/20200531105917-74697407-d67d-4b90-8a62-d361366e2f62.png 295w,\n/static/1725ffe00c17149cd8a4f3b06e8a2e06/fcda8/20200531105917-74697407-d67d-4b90-8a62-d361366e2f62.png 590w,\n/static/1725ffe00c17149cd8a4f3b06e8a2e06/9bb7a/20200531105917-74697407-d67d-4b90-8a62-d361366e2f62.png 676w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>方案</h2>\n<p>在目前的解决方案中, 使用的是 IntersectionObserver 的方案,并且不带 polyfill, 因为造成卡顿的主要原因并不是图片有没有使用懒加载. 而且 polyfill 本身可能引入额外的开销和性能问题, 在权衡下, 这次方案中没有加入 polyfill, 也没有加入 polyfill 的规划.实现懒加载的代码位于 editor.js/plugins/lazyload.</p>\n<h2>如何使用</h2>\n<h3>普通</h3>\n<p>由于在本次实现中引入了一个专门处理设计器#miniApp(目前只支持主页, 自定义页)的图片懒加载指令 v-mp-lazy, 只需要在要使用懒加载的 img 标签或其他标签(默认转化为 style:backgroundImage)添加 <code class=\"language-text\">v-mp-lazy=&quot;&lt;your image src&gt;&quot;</code> 指令即可使用懒加载. 和小程序一样, 这个懒加载是上下一屏, 总共 3 屏的加载.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>image-wrapper<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">v-mp-lazy</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://abcde.com/abcd.jpg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<h3>进阶</h3>\n<p>你可能会有特殊的需求, 例如在一个#miniApp 下的一个滚动列表使用懒加载, 这时候, 你需要直接调用 v-lazy-contianer 这个指令, 这个指令可以帮助将这个 container 标记一个父容器. 在他里面的懒加载容器需标记为 v-lazyload. 其实会发现 v-mp-lazy 也是用这种方式实现的, 在 plugins/lazyload/install.js 里同样定义了一个 v-mp-lazy-container 指令以标记父容器.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">// parentContainer.vue\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span>\n  <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>parent-container<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">v-lazy-container</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{\n  name: &lt;your container name>,\n  options: &lt;ObserverOptions without root>\n}<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n// childContainer.vue\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span>\n  <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>child-container<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">v-lazyload</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{ name: &lt;name>, src: &lt;your image src> }<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>然后你会发现什么都不会发生, 因为这部分逻辑还没实现, 你可以按照这个接口的模式, 在 plugins/lazyload/install.js 文件下完成你的实现:)</p>\n<p>如果上面的形式满足不了你(例如无法标记父容器), 你也可以使用编程式完成懒加载, 具体 api 可以参考 plugins/lazyload/lazyload.js 下的注释</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">// example // parentContainer.vue\n&lt;script&gt;\nimport { LazyLoad } from &quot;plugins/lazyload&quot;;\n  somefuncition() {\n    window._lazyload = new LazyLoad({ dataSrc: &quot;data-sth-src&quot; });\n    window._lazyload.startObserve({\n      root: $(&quot;#parent-container&quot;),\n      rootMargin: &quot;200px 0px&quot;,\n      threshold: 0,\n    })\n}\n&lt;/script&gt;\n\n// childContainer.vue\n&lt;div class=&quot;#child=container&quot;&gt;\n  &lt;div class=&quot;image-wrapper&quot; data-sth-src=&quot;https://abcd.com/abcd.jpg&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;script&gt;\nsomefuncition() {\n   window._lazyload.addTarget($(&quot;#child-container .image-wrapper&quot;));\n}\n&lt;/script&gt;</code></pre></div>\n<p>使用这个方法的重点在于, 必须保证在调用相关方法时父容器或子容器已经插入都 dom 中, 否则将无法完成 observe, 另外 lazyload 实例的生成也要考虑到, 最重要的是, 你可能需要手动调用 Lazyload.removeTarget, LazyLoad.destroy 以避免可能存在的内存泄漏. 不过 startObserve 和 addTarget 的调用时机就没有什么考究, 因为 LazyLoad 里面使用了 cache, 所以即便在 observer 未生成时你也可以将观察对象加进去.</p>\n<h2>渲染</h2>\n<p>设计器卡顿的主要原因应当是页面渲染问题. 我测试用到的是 7 张 5000px × 5000px 的图片, 每张的图片只有 100k 左右, 在页面滚动的时候, 可以看到, 主线程几乎被绘制合成过程塞爆, 鉴于我每张图片其实很小, 所以其实和图片大小是没什么关系的, 主要是因为图片像素大, 绘制合成层时间长导致的主线程阻塞.</p>\n<h3><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/64af89578a8ff5eb62c8d7f0c9d83acb/321ea/20200531105917-3ef124a3-22c3-4ca6-8a66-6130d5146a93.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.62162162162162%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAzElEQVQI1xWMy27CQAxF8/+f0kJVQVEUqbSbLisWiJBGhUAmYcbjx8yQhK7rWEeWde+RM2OMB+8cMAsAeE8iQUSMS3Vjzx13lglJmxiSOiGkaXpY55g5u8fIQkkXquWjIPnbYwjtzc0/PZq+T+IJ7HiXFDAwDIkmnXHIQqKe2u/L1+bwVLn9R73Jy0VRvnzWq/dqVRyXRbnY/rxtq3VxfM3LZX541nz6G/ftLmspNA7PCmAD1ABfQQzGk8XfGa/HjMOOorZqnpyGtjbXf/oa0xPc5N0gAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/64af89578a8ff5eb62c8d7f0c9d83acb/fcda8/20200531105917-3ef124a3-22c3-4ca6-8a66-6130d5146a93.png\"\n        srcset=\"/static/64af89578a8ff5eb62c8d7f0c9d83acb/12f09/20200531105917-3ef124a3-22c3-4ca6-8a66-6130d5146a93.png 148w,\n/static/64af89578a8ff5eb62c8d7f0c9d83acb/e4a3f/20200531105917-3ef124a3-22c3-4ca6-8a66-6130d5146a93.png 295w,\n/static/64af89578a8ff5eb62c8d7f0c9d83acb/fcda8/20200531105917-3ef124a3-22c3-4ca6-8a66-6130d5146a93.png 590w,\n/static/64af89578a8ff5eb62c8d7f0c9d83acb/321ea/20200531105917-3ef124a3-22c3-4ca6-8a66-6130d5146a93.png 786w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></h3>\n<p>通过添加 translateZ 黑魔法, 这个属性可以提升这些图片层级, 强制使用 GPU 来渲染这图层, 所以也会导致更快的渲染, 并且不会阻塞主进程.</p>\n<p>当然你也可以把<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change\">will-change</a>加上, 但是这个属性我控制不好, 可能会导致负优化, 没加.</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.image-wrapper</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">translateZ</span><span class=\"token punctuation\">(</span>0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6d43cb556a173ce640786e42cbdc7446/0a47e/20200531105917-0ef3e9c9-00f4-45e6-abb3-c3161c092c04.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAwElEQVQI1w2K2W7DIBAA/f9/10aN4sQHNrC7LMYcAYe6Dy4vo5FmunyU8zzZGetLPrK0a6015tgk1mAi6U01gV3TjrHGdm6JvffjMHaf8whvb5J0uda/jwrzdV35N4ntpaKQfl79BGlpVEFwgVSDLZBLuvVfHTuLhoBgMZ7croFcitbvQq5KgwZUCKtWgO0hicjOARtt4Pt+6+5qeRE89PrULBiExR6X0SjBOBkYCCamJ8LMuGzY6kBytjSB+ukf/1QD2m9KH2cxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/6d43cb556a173ce640786e42cbdc7446/fcda8/20200531105917-0ef3e9c9-00f4-45e6-abb3-c3161c092c04.png\"\n        srcset=\"/static/6d43cb556a173ce640786e42cbdc7446/12f09/20200531105917-0ef3e9c9-00f4-45e6-abb3-c3161c092c04.png 148w,\n/static/6d43cb556a173ce640786e42cbdc7446/e4a3f/20200531105917-0ef3e9c9-00f4-45e6-abb3-c3161c092c04.png 295w,\n/static/6d43cb556a173ce640786e42cbdc7446/fcda8/20200531105917-0ef3e9c9-00f4-45e6-abb3-c3161c092c04.png 590w,\n/static/6d43cb556a173ce640786e42cbdc7446/0a47e/20200531105917-0ef3e9c9-00f4-45e6-abb3-c3161c092c04.png 600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></h3>\n<p>这种方法只是一种 hack, 并不代表这个属性可以滥用, 最好的方法还是使用缩略图.</p>\n<h2>one more thing</h2>\n<p>本次提交中有一个 mpImage 组件, 位于/components/mpImage/, 这个组件的本意是保持和小程序<code class=\"language-text\">&lt;image&gt;</code>的同构实现的, 这次也将其中的懒加载换成 v-mp-lazy. 总之将他当成小程序的<code class=\"language-text\">&lt;image&gt;</code>标签使用即可</p>\n<div class=\"gatsby-highlight\" data-language=\"vue\"><pre class=\"language-vue\"><code class=\"language-vue\">// mode\n&lt;mp-image src=&quot;http://abcde.com/abcd.jpg&quot; mode=&quot;aspectFill&quot;&gt;&lt;/mp-image&gt;\n// lazyload\n&lt;mp-image src=&quot;http://abcde.com/abcd.jpg&quot; lazy-load&gt;&lt;/mp-image&gt;</code></pre></div>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\">Intersection Observer - Web API 接口参考| MDN</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/94426820\">IntersectionObserver 和图片懒加载 - 知乎专栏</a></p>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/image.html?search-key=lazy-load\">image | 微信开放文档 - 微信开放社区 - 腾讯</a></p>\n<p><a href=\"https://github.com/tuupola/lazyload\">tuupola/lazyload: Vanilla JavaScript plugin for … - GitHub</a></p>\n<p><a href=\"https://github.com/hilongjw/vue-lazyload\">hilongjw/vue-lazyload: A Vue.js plugin for lazyload … - GitHub</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count?hl=zh-cn\">坚持仅合成器的属性和管理层计数 - google developers</a></p>\n<p><a href=\"https://www.google.com/url?sa=t&#x26;rct=j&#x26;q=&#x26;esrc=s&#x26;source=web&#x26;cd=&#x26;ved=2ahUKEwi-jfyYydjpAhXQyosBHWB0AiAQFjAJegQIBxAB&#x26;url=https%3A%2F%2Fjuejin.im%2Fpost%2F5bdd9c506fb9a049f069b296&#x26;usg=AOvVaw1c_843nYCbOK9AGG39Ks5W\">用 CSS 开启硬件加速来提高网站性能- 掘金</a></p>\n<p><a href=\"https://juejin.im/entry/59dc9aedf265da43200232f9\">详谈层合成（composite） - 掘金</a></p>\n<p><a href=\"https://juejin.im/post/5da52531518825094e373372\">浏览器层合成与页面渲染优化</a></p>\n<p><a href=\"https://aerotwist.com/blog/on-translate3d-and-layer-creation-hacks/\">On translate3d and layer creation hacks - aerotwist</a></p>\n<p><a href=\"https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367\">You Might Not Need Redux</a>)</p>","frontmatter":{"title":"图片优化相关","date":"May 31, 2020","description":""}}},"pageContext":{"slug":"/图片优化相关/","previous":{"fields":{"slug":"/twilight patternMatch code review & explaination/"},"frontmatter":{"title":"twilight: patternMatch code review & explaination"}},"next":{"fields":{"slug":"/css 最佳实践/"},"frontmatter":{"title":"css 最佳实践"}}}}}